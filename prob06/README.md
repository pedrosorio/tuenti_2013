The map is preprocessed, and list of rocks per row and per column is built. Then, by looking at each free position (i,j) in the map and finding the closest rocks horizontally and vertically (binary search on the list of rocks at line i, binary search on the list of rocks at column j) the adjacency list of each node is built in O(log(H) + log(W)). 

Here the code could be improved since we are building adjacency lists for nodes that will never be reached (those that are not adjacent to any rock), which is an unnecessary cost in memory for large and empty maps - the most efficient approach would not store any map, just have the lists of rocks per column and row plus a dictionary of rock positions, each rock's adjacent positions would then be checked to see if they are free and only then added to the graph.

The weight of each edge is given by the distance between the nodes + T * S (which is an integer, instead of distance / S + T, which is the time required to cross the edge). All that is left is to find the shortest path between the beginning and the end in this graph using Dijkstra and divide the total weight by S, giving the total time spent. 